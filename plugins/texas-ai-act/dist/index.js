/**
 * Texas Responsible AI Governance Act (TRAIGA) Framework Plugin (Bundled)
 * Generated by build-framework-plugins.js
 */

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// plugins/texas-ai-act/index.ts
var index_exports = {};
__export(index_exports, {
  install: () => install,
  metadata: () => metadata,
  router: () => router,
  uninstall: () => uninstall,
  validateConfig: () => validateConfig
});
module.exports = __toCommonJS(index_exports);

// packages/custom-framework-base/index.ts
async function ensureSharedTables(sequelize, tenantId) {
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_frameworks (
      id SERIAL PRIMARY KEY,
      plugin_key VARCHAR(100),
      name VARCHAR(255) NOT NULL,
      description TEXT,
      version VARCHAR(50) DEFAULT '1.0.0',
      is_organizational BOOLEAN DEFAULT FALSE,
      hierarchy_type VARCHAR(50) NOT NULL DEFAULT 'two_level',
      level_1_name VARCHAR(100) NOT NULL DEFAULT 'Category',
      level_2_name VARCHAR(100) NOT NULL DEFAULT 'Control',
      level_3_name VARCHAR(100),
      file_source VARCHAR(100),
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = '${tenantId}'
        AND table_name = 'custom_frameworks'
        AND column_name = 'plugin_key'
      ) THEN
        ALTER TABLE "${tenantId}".custom_frameworks ADD COLUMN plugin_key VARCHAR(100);
      END IF;
    END $$;
  `);
  await sequelize.query(`
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = '${tenantId}'
        AND table_name = 'custom_frameworks'
        AND column_name = 'file_source'
      ) THEN
        ALTER TABLE "${tenantId}".custom_frameworks ADD COLUMN file_source VARCHAR(100);
      END IF;
    END $$;
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level1 (
      id SERIAL PRIMARY KEY,
      framework_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_frameworks(id) ON DELETE CASCADE,
      title VARCHAR(500) NOT NULL,
      description TEXT,
      order_no INTEGER NOT NULL DEFAULT 1,
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level2 (
      id SERIAL PRIMARY KEY,
      level1_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level1(id) ON DELETE CASCADE,
      title VARCHAR(500) NOT NULL,
      description TEXT,
      order_no INTEGER NOT NULL DEFAULT 1,
      summary TEXT,
      questions TEXT[],
      evidence_examples TEXT[],
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level3 (
      id SERIAL PRIMARY KEY,
      level2_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level2(id) ON DELETE CASCADE,
      title VARCHAR(500) NOT NULL,
      description TEXT,
      order_no INTEGER NOT NULL DEFAULT 1,
      summary TEXT,
      questions TEXT[],
      evidence_examples TEXT[],
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_projects (
      id SERIAL PRIMARY KEY,
      framework_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_frameworks(id) ON DELETE CASCADE,
      project_id INTEGER NOT NULL,
      created_at TIMESTAMP DEFAULT NOW(),
      UNIQUE(framework_id, project_id)
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level2_impl (
      id SERIAL PRIMARY KEY,
      level2_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level2(id) ON DELETE CASCADE,
      project_framework_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_projects(id) ON DELETE CASCADE,
      status VARCHAR(50) DEFAULT 'Not started',
      owner INTEGER,
      reviewer INTEGER,
      approver INTEGER,
      due_date DATE,
      implementation_details TEXT,
      evidence_links JSONB DEFAULT '[]',
      feedback_links JSONB DEFAULT '[]',
      auditor_feedback TEXT,
      is_demo BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level3_impl (
      id SERIAL PRIMARY KEY,
      level3_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level3(id) ON DELETE CASCADE,
      level2_impl_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level2_impl(id) ON DELETE CASCADE,
      status VARCHAR(50) DEFAULT 'Not started',
      owner INTEGER,
      reviewer INTEGER,
      approver INTEGER,
      due_date DATE,
      implementation_details TEXT,
      evidence_links JSONB DEFAULT '[]',
      feedback_links JSONB DEFAULT '[]',
      auditor_feedback TEXT,
      is_demo BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level2_risks (
      level2_impl_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level2_impl(id) ON DELETE CASCADE,
      risk_id INTEGER NOT NULL,
      PRIMARY KEY (level2_impl_id, risk_id)
    )
  `);
  await sequelize.query(`
    CREATE TABLE IF NOT EXISTS "${tenantId}".custom_framework_level3_risks (
      level3_impl_id INTEGER NOT NULL REFERENCES "${tenantId}".custom_framework_level3_impl(id) ON DELETE CASCADE,
      risk_id INTEGER NOT NULL,
      PRIMARY KEY (level3_impl_id, risk_id)
    )
  `);
  const indexes = [
    `CREATE INDEX IF NOT EXISTS idx_cf_level1_framework ON "${tenantId}".custom_framework_level1(framework_id)`,
    `CREATE INDEX IF NOT EXISTS idx_cf_level2_level1 ON "${tenantId}".custom_framework_level2(level1_id)`,
    `CREATE INDEX IF NOT EXISTS idx_cf_level3_level2 ON "${tenantId}".custom_framework_level3(level2_id)`,
    `CREATE INDEX IF NOT EXISTS idx_cf_l2impl_pf ON "${tenantId}".custom_framework_level2_impl(project_framework_id)`,
    `CREATE INDEX IF NOT EXISTS idx_cf_l3impl_l2impl ON "${tenantId}".custom_framework_level3_impl(level2_impl_id)`,
    `CREATE INDEX IF NOT EXISTS idx_cf_plugin_key ON "${tenantId}".custom_frameworks(plugin_key)`
  ];
  for (const idx of indexes) {
    await sequelize.query(idx);
  }
}
function toPgArray(arr) {
  if (!arr || arr.length === 0) return "{}";
  const escaped = arr.map((item) => {
    const escapedItem = String(item).replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return `"${escapedItem}"`;
  });
  return `{${escaped.join(",")}}`;
}
function generateFileSourceName(frameworkName) {
  const cleanName = frameworkName.trim();
  return `${cleanName} evidence`;
}
async function addFileSourceEnum(sequelize, sourceName) {
  try {
    const [existing] = await sequelize.query(
      `
      SELECT 1 FROM pg_enum
      WHERE enumtypid = (SELECT oid FROM pg_type WHERE typname = 'enum_files_source')
      AND enumlabel = :sourceName
    `,
      { replacements: { sourceName } }
    );
    if (existing.length === 0) {
      await sequelize.query(
        `ALTER TYPE public.enum_files_source ADD VALUE '${sourceName.replace(/'/g, "''")}'`
      );
      console.log(`[CustomFrameworkBase] Added file source enum: "${sourceName}"`);
    }
    return true;
  } catch (error) {
    console.error(`[CustomFrameworkBase] Failed to add file source enum: ${error.message}`);
    return false;
  }
}
async function importFramework(frameworkData, tenantId, sequelize, pluginKey) {
  const fileSource = generateFileSourceName(frameworkData.name);
  await addFileSourceEnum(sequelize, fileSource);
  const transaction = await sequelize.transaction();
  try {
    const [frameworkResult] = await sequelize.query(
      `INSERT INTO "${tenantId}".custom_frameworks
       (plugin_key, name, description, version, is_organizational, hierarchy_type, level_1_name, level_2_name, level_3_name, file_source, created_at)
       VALUES (:plugin_key, :name, :description, :version, :is_organizational, :hierarchy_type, :level_1_name, :level_2_name, :level_3_name, :file_source, NOW())
       RETURNING id`,
      {
        replacements: {
          plugin_key: pluginKey,
          name: frameworkData.name,
          description: frameworkData.description,
          version: frameworkData.version || "1.0.0",
          is_organizational: frameworkData.is_organizational,
          hierarchy_type: frameworkData.hierarchy.type,
          level_1_name: frameworkData.hierarchy.level1_name,
          level_2_name: frameworkData.hierarchy.level2_name,
          level_3_name: frameworkData.hierarchy.level3_name || null,
          file_source: fileSource
        },
        transaction
      }
    );
    const frameworkId = frameworkResult[0].id;
    let itemsCreated = 0;
    for (const level1 of frameworkData.structure) {
      const [level1Result] = await sequelize.query(
        `INSERT INTO "${tenantId}".custom_framework_level1
         (framework_id, title, description, order_no, metadata)
         VALUES (:framework_id, :title, :description, :order_no, :metadata)
         RETURNING id`,
        {
          replacements: {
            framework_id: frameworkId,
            title: level1.title,
            description: level1.description || null,
            order_no: level1.order_no,
            metadata: JSON.stringify(level1.metadata || {})
          },
          transaction
        }
      );
      const level1Id = level1Result[0].id;
      itemsCreated++;
      for (const level2 of level1.items || []) {
        const [level2Result] = await sequelize.query(
          `INSERT INTO "${tenantId}".custom_framework_level2
           (level1_id, title, description, order_no, summary, questions, evidence_examples, metadata)
           VALUES (:level1_id, :title, :description, :order_no, :summary, :questions, :evidence_examples, :metadata)
           RETURNING id`,
          {
            replacements: {
              level1_id: level1Id,
              title: level2.title,
              description: level2.description || null,
              order_no: level2.order_no,
              summary: level2.summary || null,
              questions: toPgArray(level2.questions),
              evidence_examples: toPgArray(level2.evidence_examples),
              metadata: JSON.stringify(level2.metadata || {})
            },
            transaction
          }
        );
        const level2Id = level2Result[0].id;
        itemsCreated++;
        if (frameworkData.hierarchy.type === "three_level" && level2.items) {
          for (const level3 of level2.items) {
            await sequelize.query(
              `INSERT INTO "${tenantId}".custom_framework_level3
               (level2_id, title, description, order_no, summary, questions, evidence_examples, metadata)
               VALUES (:level2_id, :title, :description, :order_no, :summary, :questions, :evidence_examples, :metadata)`,
              {
                replacements: {
                  level2_id: level2Id,
                  title: level3.title,
                  description: level3.description || null,
                  order_no: level3.order_no,
                  summary: level3.summary || null,
                  questions: toPgArray(level3.questions),
                  evidence_examples: toPgArray(level3.evidence_examples),
                  metadata: JSON.stringify(level3.metadata || {})
                },
                transaction
              }
            );
            itemsCreated++;
          }
        }
      }
    }
    await transaction.commit();
    return { frameworkId, itemsCreated, fileSource };
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
function createRouteHandlers(pluginKey, config) {
  async function handleGetFrameworks(ctx) {
    const { sequelize, tenantId, query } = ctx;
    const showAll = query.all === "true";
    try {
      const whereClause = showAll ? "1=1" : "cf.plugin_key = :pluginKey OR cf.plugin_key IS NULL";
      const [frameworks] = await sequelize.query(
        `
        SELECT
          cf.id,
          cf.plugin_key,
          cf.name,
          cf.description,
          cf.version,
          cf.is_organizational,
          cf.hierarchy_type,
          cf.level_1_name,
          cf.level_2_name,
          cf.level_3_name,
          cf.file_source,
          cf.created_at,
          (SELECT COUNT(*) FROM "${tenantId}".custom_framework_level1 WHERE framework_id = cf.id) as level1_count,
          (SELECT COUNT(*) FROM "${tenantId}".custom_framework_level2 l2
           JOIN "${tenantId}".custom_framework_level1 l1 ON l2.level1_id = l1.id
           WHERE l1.framework_id = cf.id) as level2_count,
          (SELECT COUNT(*) FROM "${tenantId}".custom_framework_level3 l3
           JOIN "${tenantId}".custom_framework_level2 l2 ON l3.level2_id = l2.id
           JOIN "${tenantId}".custom_framework_level1 l1 ON l2.level1_id = l1.id
           WHERE l1.framework_id = cf.id) as level3_count
        FROM "${tenantId}".custom_frameworks cf
        WHERE ${whereClause}
        ORDER BY cf.created_at DESC
      `,
        { replacements: { pluginKey } }
      );
      return { status: 200, data: frameworks };
    } catch (error) {
      return { status: 500, data: { message: `Failed to fetch frameworks: ${error.message}` } };
    }
  }
  async function handleGetFrameworkById(ctx) {
    const { sequelize, tenantId, params } = ctx;
    const frameworkId = parseInt(params.frameworkId);
    try {
      const [meta] = await sequelize.query(
        `SELECT * FROM "${tenantId}".custom_frameworks WHERE id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      if (meta.length === 0) {
        return { status: 404, data: { message: "Framework not found" } };
      }
      const [level1Items] = await sequelize.query(
        `SELECT * FROM "${tenantId}".custom_framework_level1
         WHERE framework_id = :frameworkId ORDER BY order_no`,
        { replacements: { frameworkId } }
      );
      for (const l1 of level1Items) {
        const [level2Items] = await sequelize.query(
          `SELECT * FROM "${tenantId}".custom_framework_level2
           WHERE level1_id = :level1Id ORDER BY order_no`,
          { replacements: { level1Id: l1.id } }
        );
        for (const l2 of level2Items) {
          if (meta[0].hierarchy_type === "three_level") {
            const [level3Items] = await sequelize.query(
              `SELECT * FROM "${tenantId}".custom_framework_level3
               WHERE level2_id = :level2Id ORDER BY order_no`,
              { replacements: { level2Id: l2.id } }
            );
            l2.items = level3Items;
          }
        }
        l1.items = level2Items;
      }
      const [linkedProjectsRaw] = await sequelize.query(
        `SELECT
          cfp.id as project_framework_id,
          cfp.project_id,
          cfp.created_at as added_at,
          p.project_title,
          COALESCE(p.is_organizational, false) as is_organizational
        FROM "${tenantId}".custom_framework_projects cfp
        JOIN "${tenantId}".projects p ON cfp.project_id = p.id
        WHERE cfp.framework_id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      const linkedProjects = await Promise.all(
        linkedProjectsRaw.map(async (proj) => {
          let progressData;
          if (meta[0].hierarchy_type === "three_level") {
            [progressData] = await sequelize.query(
              `SELECT
                COUNT(*) as total,
                SUM(CASE WHEN l3.status = 'Implemented' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN l3.owner IS NOT NULL THEN 1 ELSE 0 END) as assigned
              FROM "${tenantId}".custom_framework_level3_impl l3
              JOIN "${tenantId}".custom_framework_level2_impl l2 ON l3.level2_impl_id = l2.id
              WHERE l2.project_framework_id = :projectFrameworkId`,
              { replacements: { projectFrameworkId: proj.project_framework_id } }
            );
          } else {
            [progressData] = await sequelize.query(
              `SELECT
                COUNT(*) as total,
                SUM(CASE WHEN status = 'Implemented' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN owner IS NOT NULL THEN 1 ELSE 0 END) as assigned
              FROM "${tenantId}".custom_framework_level2_impl
              WHERE project_framework_id = :projectFrameworkId`,
              { replacements: { projectFrameworkId: proj.project_framework_id } }
            );
          }
          const total = parseInt(progressData[0]?.total || "0");
          const completed = parseInt(progressData[0]?.completed || "0");
          const assigned = parseInt(progressData[0]?.assigned || "0");
          return {
            project_framework_id: proj.project_framework_id,
            project_id: proj.project_id,
            project_title: proj.project_title,
            is_organizational: proj.is_organizational,
            added_at: proj.added_at,
            progress: {
              total,
              completed,
              assigned,
              percentage: total > 0 ? Math.round(completed / total * 100) : 0
            }
          };
        })
      );
      return {
        status: 200,
        data: {
          ...meta[0],
          structure: level1Items,
          linkedProjects
        }
      };
    } catch (error) {
      return { status: 500, data: { message: `Failed to fetch structure: ${error.message}` } };
    }
  }
  async function handleDeleteFramework(ctx) {
    const { sequelize, tenantId, params } = ctx;
    const frameworkId = parseInt(params.frameworkId);
    try {
      const [framework] = await sequelize.query(
        `SELECT id FROM "${tenantId}".custom_frameworks WHERE id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      if (framework.length === 0) {
        return { status: 404, data: { message: "Framework not found" } };
      }
      const [projects] = await sequelize.query(
        `SELECT COUNT(*) as count FROM "${tenantId}".custom_framework_projects WHERE framework_id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      if (parseInt(projects[0].count) > 0) {
        await sequelize.query(
          `DELETE FROM "${tenantId}".custom_framework_projects WHERE framework_id = :frameworkId`,
          { replacements: { frameworkId } }
        );
      }
      await sequelize.query(`DELETE FROM "${tenantId}".custom_frameworks WHERE id = :frameworkId`, {
        replacements: { frameworkId }
      });
      return { status: 200, data: { success: true, message: "Framework deleted" } };
    } catch (error) {
      return { status: 500, data: { message: `Delete failed: ${error.message}` } };
    }
  }
  async function handleAddToProject(ctx) {
    const { sequelize, tenantId, body } = ctx;
    const { frameworkId, projectId } = body;
    if (!frameworkId || !projectId) {
      return { status: 400, data: { message: "frameworkId and projectId are required" } };
    }
    try {
      const [framework] = await sequelize.query(
        `SELECT id, hierarchy_type FROM "${tenantId}".custom_frameworks WHERE id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      if (framework.length === 0) {
        return { status: 404, data: { message: "Framework not found" } };
      }
      const hierarchyType = framework[0].hierarchy_type;
      const [existing] = await sequelize.query(
        `SELECT id FROM "${tenantId}".custom_framework_projects
         WHERE framework_id = :frameworkId AND project_id = :projectId`,
        { replacements: { frameworkId, projectId } }
      );
      if (existing.length > 0) {
        return { status: 400, data: { message: "Framework already added to this project" } };
      }
      const [insertResult] = await sequelize.query(
        `INSERT INTO "${tenantId}".custom_framework_projects (framework_id, project_id, created_at)
         VALUES (:frameworkId, :projectId, NOW())
         RETURNING id`,
        { replacements: { frameworkId, projectId } }
      );
      const projectFrameworkId = insertResult[0].id;
      const [level2Items] = await sequelize.query(
        `SELECT l2.id FROM "${tenantId}".custom_framework_level2 l2
         JOIN "${tenantId}".custom_framework_level1 l1 ON l2.level1_id = l1.id
         WHERE l1.framework_id = :frameworkId`,
        { replacements: { frameworkId } }
      );
      for (const l2 of level2Items) {
        const [implResult] = await sequelize.query(
          `INSERT INTO "${tenantId}".custom_framework_level2_impl
           (level2_id, project_framework_id, status, created_at, updated_at)
           VALUES (:level2_id, :project_framework_id, 'Not started', NOW(), NOW())
           RETURNING id`,
          { replacements: { level2_id: l2.id, project_framework_id: projectFrameworkId } }
        );
        if (hierarchyType === "three_level") {
          const [level3Items] = await sequelize.query(
            `SELECT id FROM "${tenantId}".custom_framework_level3 WHERE level2_id = :level2Id`,
            { replacements: { level2Id: l2.id } }
          );
          for (const l3 of level3Items) {
            await sequelize.query(
              `INSERT INTO "${tenantId}".custom_framework_level3_impl
               (level3_id, level2_impl_id, status, created_at, updated_at)
               VALUES (:level3_id, :level2_impl_id, 'Not started', NOW(), NOW())`,
              { replacements: { level3_id: l3.id, level2_impl_id: implResult[0].id } }
            );
          }
        }
      }
      return {
        status: 200,
        data: { success: true, message: "Framework added to project", projectFrameworkId }
      };
    } catch (error) {
      return { status: 500, data: { message: `Failed to add: ${error.message}` } };
    }
  }
  async function handleRemoveFromProject(ctx) {
    const { sequelize, tenantId, body } = ctx;
    const { frameworkId, projectId } = body;
    if (!frameworkId || !projectId) {
      return { status: 400, data: { message: "frameworkId and projectId are required" } };
    }
    try {
      await sequelize.query(
        `DELETE FROM "${tenantId}".custom_framework_projects
         WHERE framework_id = :frameworkId AND project_id = :projectId`,
        { replacements: { frameworkId, projectId } }
      );
      return { status: 200, data: { success: true, message: "Framework removed from project" } };
    } catch (error) {
      return { status: 500, data: { message: `Failed to remove: ${error.message}` } };
    }
  }
  async function handleGetProjectFrameworks(ctx) {
    const { sequelize, tenantId, params, query } = ctx;
    const projectId = parseInt(params.projectId);
    const isOrganizational = query.is_organizational === "true";
    try {
      const [frameworks] = await sequelize.query(
        `
        SELECT cf.*, cf.id as framework_id, cfp.id as project_framework_id, cfp.created_at as added_at
        FROM "${tenantId}".custom_frameworks cf
        JOIN "${tenantId}".custom_framework_projects cfp ON cf.id = cfp.framework_id
        WHERE cfp.project_id = :projectId
        ORDER BY cf.name
      `,
        { replacements: { projectId } }
      );
      return { status: 200, data: frameworks };
    } catch (error) {
      return { status: 500, data: { message: error.message } };
    }
  }
  async function handleGetProjectFramework(ctx) {
    const { sequelize, tenantId, params } = ctx;
    const projectId = parseInt(params.projectId);
    const frameworkId = parseInt(params.frameworkId);
    try {
      const [projectFramework] = await sequelize.query(
        `SELECT cfp.id as project_framework_id, cf.*
         FROM "${tenantId}".custom_framework_projects cfp
         JOIN "${tenantId}".custom_frameworks cf ON cfp.framework_id = cf.id
         WHERE cfp.project_id = :projectId AND cfp.framework_id = :frameworkId`,
        { replacements: { projectId, frameworkId } }
      );
      if (projectFramework.length === 0) {
        return { status: 404, data: { message: "Framework not found in project" } };
      }
      const pf = projectFramework[0];
      const projectFrameworkId = pf.project_framework_id;
      const [level1Items] = await sequelize.query(
        `SELECT * FROM "${tenantId}".custom_framework_level1
         WHERE framework_id = :frameworkId ORDER BY order_no`,
        { replacements: { frameworkId } }
      );
      for (const l1 of level1Items) {
        const [level2Items] = await sequelize.query(
          `SELECT l2.*,
                  impl.id as impl_id, impl.status, impl.owner, impl.reviewer, impl.approver,
                  impl.due_date, impl.implementation_details, impl.evidence_links,
                  impl.feedback_links, impl.auditor_feedback,
                  u_owner.name as owner_name, u_owner.surname as owner_surname,
                  u_reviewer.name as reviewer_name, u_reviewer.surname as reviewer_surname,
                  u_approver.name as approver_name, u_approver.surname as approver_surname
           FROM "${tenantId}".custom_framework_level2 l2
           LEFT JOIN "${tenantId}".custom_framework_level2_impl impl
             ON l2.id = impl.level2_id AND impl.project_framework_id = :projectFrameworkId
           LEFT JOIN public.users u_owner ON impl.owner = u_owner.id
           LEFT JOIN public.users u_reviewer ON impl.reviewer = u_reviewer.id
           LEFT JOIN public.users u_approver ON impl.approver = u_approver.id
           WHERE l2.level1_id = :level1Id
           ORDER BY l2.order_no`,
          { replacements: { level1Id: l1.id, projectFrameworkId } }
        );
        for (const l2 of level2Items) {
          if (l2.impl_id) {
            const [risks] = await sequelize.query(
              `SELECT r.id, r.risk_name, r.risk_description
               FROM "${tenantId}".custom_framework_level2_risks lr
               JOIN "${tenantId}".risks r ON lr.risk_id = r.id
               WHERE lr.level2_impl_id = :implId`,
              { replacements: { implId: l2.impl_id } }
            );
            l2.linked_risks = risks;
          } else {
            l2.linked_risks = [];
          }
          if (pf.hierarchy_type === "three_level") {
            const [level3Items] = await sequelize.query(
              `SELECT l3.*,
                      impl.id as impl_id, impl.status, impl.owner, impl.reviewer, impl.approver,
                      impl.due_date, impl.implementation_details, impl.evidence_links
               FROM "${tenantId}".custom_framework_level3 l3
               LEFT JOIN "${tenantId}".custom_framework_level3_impl impl
                 ON l3.id = impl.level3_id AND impl.level2_impl_id = :level2ImplId
               WHERE l3.level2_id = :level2Id
               ORDER BY l3.order_no`,
              { replacements: { level2Id: l2.id, level2ImplId: l2.impl_id } }
            );
            l2.items = level3Items;
          }
        }
        l1.items = level2Items;
      }
      return {
        status: 200,
        data: {
          projectFrameworkId,
          frameworkId: pf.id,
          name: pf.name,
          description: pf.description,
          is_organizational: pf.is_organizational,
          hierarchy_type: pf.hierarchy_type,
          level_1_name: pf.level_1_name,
          level_2_name: pf.level_2_name,
          level_3_name: pf.level_3_name,
          file_source: pf.file_source,
          structure: level1Items
        }
      };
    } catch (error) {
      return { status: 500, data: { message: error.message } };
    }
  }
  async function handleGetProgress(ctx) {
    const { sequelize, tenantId, params } = ctx;
    const projectId = parseInt(params.projectId);
    const frameworkId = parseInt(params.frameworkId);
    try {
      const [projectFramework] = await sequelize.query(
        `SELECT cfp.id as project_framework_id, cf.hierarchy_type
         FROM "${tenantId}".custom_framework_projects cfp
         JOIN "${tenantId}".custom_frameworks cf ON cfp.framework_id = cf.id
         WHERE cfp.project_id = :projectId AND cfp.framework_id = :frameworkId`,
        { replacements: { projectId, frameworkId } }
      );
      if (projectFramework.length === 0) {
        return { status: 404, data: { message: "Framework not found in project" } };
      }
      const projectFrameworkId = projectFramework[0].project_framework_id;
      const hierarchyType = projectFramework[0].hierarchy_type;
      const [level2Stats] = await sequelize.query(
        `SELECT
           COUNT(*) as total,
           COUNT(CASE WHEN status = 'Implemented' THEN 1 END) as completed,
           COUNT(CASE WHEN owner IS NOT NULL THEN 1 END) as assigned
         FROM "${tenantId}".custom_framework_level2_impl
         WHERE project_framework_id = :projectFrameworkId`,
        { replacements: { projectFrameworkId } }
      );
      const result = {
        level2: {
          total: parseInt(level2Stats[0].total),
          completed: parseInt(level2Stats[0].completed),
          assigned: parseInt(level2Stats[0].assigned),
          percentage: parseInt(level2Stats[0].total) > 0 ? Math.round(
            parseInt(level2Stats[0].completed) / parseInt(level2Stats[0].total) * 100
          ) : 0
        }
      };
      if (hierarchyType === "three_level") {
        const [level3Stats] = await sequelize.query(
          `SELECT
             COUNT(*) as total,
             COUNT(CASE WHEN l3.status = 'Implemented' THEN 1 END) as completed,
             COUNT(CASE WHEN l3.owner IS NOT NULL THEN 1 END) as assigned
           FROM "${tenantId}".custom_framework_level3_impl l3
           JOIN "${tenantId}".custom_framework_level2_impl l2 ON l3.level2_impl_id = l2.id
           WHERE l2.project_framework_id = :projectFrameworkId`,
          { replacements: { projectFrameworkId } }
        );
        result.level3 = {
          total: parseInt(level3Stats[0].total),
          completed: parseInt(level3Stats[0].completed),
          assigned: parseInt(level3Stats[0].assigned),
          percentage: parseInt(level3Stats[0].total) > 0 ? Math.round(
            parseInt(level3Stats[0].completed) / parseInt(level3Stats[0].total) * 100
          ) : 0
        };
        result.overall = result.level3;
      } else {
        result.overall = result.level2;
      }
      return { status: 200, data: result };
    } catch (error) {
      return { status: 500, data: { message: error.message } };
    }
  }
  async function handleUpdateLevel2(ctx) {
    const { sequelize, tenantId, params, body } = ctx;
    const implId = parseInt(params.level2Id);
    try {
      const updateFields = [];
      const replacements = { id: implId };
      const allowedFields = [
        "status",
        "owner",
        "reviewer",
        "approver",
        "due_date",
        "implementation_details",
        "evidence_links",
        "feedback_links",
        "auditor_feedback"
      ];
      for (const field of allowedFields) {
        if (body[field] !== void 0) {
          if (field === "evidence_links" || field === "feedback_links") {
            updateFields.push(`${field} = :${field}::jsonb`);
            replacements[field] = JSON.stringify(body[field]);
          } else if (field === "due_date" && body[field] === null) {
            updateFields.push(`${field} = NULL`);
          } else {
            updateFields.push(`${field} = :${field}`);
            replacements[field] = body[field];
          }
        }
      }
      if (updateFields.length === 0) {
        return { status: 400, data: { message: "No fields to update" } };
      }
      updateFields.push("updated_at = NOW()");
      await sequelize.query(
        `UPDATE "${tenantId}".custom_framework_level2_impl
         SET ${updateFields.join(", ")}
         WHERE id = :id`,
        { replacements }
      );
      if (body.risks_to_add && Array.isArray(body.risks_to_add)) {
        for (const riskId of body.risks_to_add) {
          await sequelize.query(
            `INSERT INTO "${tenantId}".custom_framework_level2_risks (level2_impl_id, risk_id)
             VALUES (:implId, :riskId)
             ON CONFLICT DO NOTHING`,
            { replacements: { implId, riskId } }
          );
        }
      }
      if (body.risks_to_remove && Array.isArray(body.risks_to_remove)) {
        await sequelize.query(
          `DELETE FROM "${tenantId}".custom_framework_level2_risks
           WHERE level2_impl_id = :implId AND risk_id = ANY(:risks)`,
          { replacements: { implId, risks: body.risks_to_remove } }
        );
      }
      return { status: 200, data: { success: true, message: "Updated successfully" } };
    } catch (error) {
      return { status: 500, data: { message: `Update failed: ${error.message}` } };
    }
  }
  async function handleUpdateLevel3(ctx) {
    const { sequelize, tenantId, params, body } = ctx;
    const implId = parseInt(params.level3Id);
    try {
      const updateFields = [];
      const replacements = { id: implId };
      const allowedFields = [
        "status",
        "owner",
        "reviewer",
        "approver",
        "due_date",
        "implementation_details",
        "evidence_links",
        "feedback_links",
        "auditor_feedback"
      ];
      for (const field of allowedFields) {
        if (body[field] !== void 0) {
          if (field === "evidence_links" || field === "feedback_links") {
            updateFields.push(`${field} = :${field}::jsonb`);
            replacements[field] = JSON.stringify(body[field]);
          } else if (field === "due_date" && body[field] === null) {
            updateFields.push(`${field} = NULL`);
          } else {
            updateFields.push(`${field} = :${field}`);
            replacements[field] = body[field];
          }
        }
      }
      if (updateFields.length === 0) {
        return { status: 400, data: { message: "No fields to update" } };
      }
      updateFields.push("updated_at = NOW()");
      await sequelize.query(
        `UPDATE "${tenantId}".custom_framework_level3_impl
         SET ${updateFields.join(", ")}
         WHERE id = :id`,
        { replacements }
      );
      return { status: 200, data: { success: true, message: "Updated successfully" } };
    } catch (error) {
      return { status: 500, data: { message: `Update failed: ${error.message}` } };
    }
  }
  return {
    handleGetFrameworks,
    handleGetFrameworkById,
    handleDeleteFramework,
    handleAddToProject,
    handleRemoveFromProject,
    handleGetProjectFrameworks,
    handleGetProjectFramework,
    handleGetProgress,
    handleUpdateLevel2,
    handleUpdateLevel3
  };
}
function createFrameworkPlugin(config) {
  const pluginKey = config.key;
  const metadata2 = {
    name: config.name,
    version: config.version || "1.0.0",
    author: config.author || "VerifyWise",
    description: config.description
  };
  async function install2(_userId, tenantId, _config, context) {
    const { sequelize } = context;
    try {
      await ensureSharedTables(sequelize, tenantId);
      if (config.autoImport !== false && config.template) {
        const [existing] = await sequelize.query(
          `SELECT id FROM "${tenantId}".custom_frameworks WHERE plugin_key = :pluginKey`,
          { replacements: { pluginKey } }
        );
        if (existing.length === 0) {
          const result = await importFramework(config.template, tenantId, sequelize, pluginKey);
          console.log(
            `[${config.name}] Auto-imported framework with ${result.itemsCreated} items`
          );
        }
      }
      return {
        success: true,
        message: `${config.name} plugin installed successfully.`,
        installedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      throw new Error(`Installation failed: ${error.message}`);
    }
  }
  async function uninstall2(_userId, tenantId, context) {
    const { sequelize } = context;
    try {
      const [frameworks] = await sequelize.query(
        `SELECT id FROM "${tenantId}".custom_frameworks WHERE plugin_key = :pluginKey`,
        { replacements: { pluginKey } }
      );
      const frameworkIds = frameworks.map((f) => f.id);
      if (frameworkIds.length > 0) {
        await sequelize.query(
          `DELETE FROM "${tenantId}".custom_framework_projects WHERE framework_id IN (:ids)`,
          { replacements: { ids: frameworkIds } }
        );
        await sequelize.query(
          `DELETE FROM "${tenantId}".custom_frameworks WHERE plugin_key = :pluginKey`,
          { replacements: { pluginKey } }
        );
      }
      return {
        success: true,
        message: `${config.name} plugin uninstalled successfully.`,
        uninstalledAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      throw new Error(`Uninstall failed: ${error.message}`);
    }
  }
  function validateConfig2(_config) {
    return { valid: true, errors: [] };
  }
  const handlers = createRouteHandlers(pluginKey, config);
  const router2 = {
    "GET /frameworks": handlers.handleGetFrameworks,
    "GET /frameworks/:frameworkId": handlers.handleGetFrameworkById,
    "DELETE /frameworks/:frameworkId": handlers.handleDeleteFramework,
    "POST /add-to-project": handlers.handleAddToProject,
    "POST /remove-from-project": handlers.handleRemoveFromProject,
    "GET /projects/:projectId/custom-frameworks": handlers.handleGetProjectFrameworks,
    "GET /projects/:projectId/frameworks/:frameworkId": handlers.handleGetProjectFramework,
    "GET /projects/:projectId/frameworks/:frameworkId/progress": handlers.handleGetProgress,
    "PATCH /level2/:level2Id": handlers.handleUpdateLevel2,
    "PATCH /level3/:level3Id": handlers.handleUpdateLevel3
  };
  return {
    metadata: metadata2,
    install: install2,
    uninstall: uninstall2,
    validateConfig: validateConfig2,
    router: router2
  };
}

// plugins/texas-ai-act/template.json
var template_default = {
  id: "texas-ai-act",
  name: "Texas Responsible AI Governance Act (TRAIGA)",
  description: "Texas Responsible AI Governance Act compliance framework for organizations deploying high-risk AI systems in Texas.",
  category: "AI Governance",
  tags: ["Texas", "AI Act", "TRAIGA", "AI Governance", "United States", "High-Risk AI"],
  framework: {
    name: "Texas Responsible AI Governance Act Framework",
    description: "Framework for ensuring compliance with the Texas Responsible AI Governance Act (TRAIGA) which regulates the development, deployment, and use of high-risk artificial intelligence systems in Texas",
    version: "1.0.0",
    is_organizational: false,
    hierarchy: {
      type: "two_level",
      level1_name: "Chapter",
      level2_name: "Section"
    },
    structure: [
      {
        title: "Chapter 1: Definitions and Scope",
        description: "Key definitions, scope of application, and determination of high-risk AI systems under TRAIGA",
        order_no: 1,
        items: [
          {
            title: "Sec. 1.1 - High-Risk AI System Identification",
            description: "Determine whether AI systems qualify as high-risk under TRAIGA based on their use and impact",
            order_no: 1,
            summary: "High-risk AI systems include those used in: employment decisions, educational opportunities, financial services, healthcare, housing, insurance, legal services, and essential government services. Systems making consequential decisions about individuals require compliance",
            questions: [
              "Does the AI system make or substantially contribute to consequential decisions?",
              "Is the AI used in employment, education, financial, healthcare, or housing contexts?",
              "Does the system affect access to essential services?",
              "Is there human oversight of AI-generated decisions?"
            ],
            evidence_examples: [
              "AI system inventory with risk classification",
              "Use case documentation",
              "Decision impact assessment",
              "High-risk determination analysis"
            ]
          },
          {
            title: "Sec. 1.2 - Deployer vs Developer Responsibilities",
            description: "Understand and document roles as AI deployer, developer, or both",
            order_no: 2,
            summary: "Deployers (organizations using AI) and developers (organizations creating AI) have distinct obligations. Many organizations serve both roles. Document which obligations apply based on your role",
            questions: [
              "Is your organization a deployer, developer, or both?",
              "Are developer obligations contractually addressed?",
              "Is there clear allocation of compliance responsibilities?",
              "Are third-party AI vendors properly vetted?"
            ],
            evidence_examples: [
              "Role determination documentation",
              "Vendor contracts with compliance provisions",
              "Responsibility allocation matrix",
              "Third-party AI vendor assessments"
            ]
          },
          {
            title: "Sec. 1.3 - Exemptions Assessment",
            description: "Determine if any statutory exemptions apply to your AI systems",
            order_no: 3,
            summary: "Certain AI systems may be exempt, including: federally regulated AI, national security applications, anti-fraud systems in certain contexts, and AI used solely for internal research. Document exemption basis if claimed",
            questions: [
              "Are any AI systems federally regulated?",
              "Are exemptions properly documented and justified?",
              "Is the exemption analysis reviewed periodically?",
              "Are exempt systems still subject to voluntary best practices?"
            ],
            evidence_examples: [
              "Exemption analysis documentation",
              "Federal regulation mapping",
              "Legal opinion on exemptions",
              "Periodic exemption review records"
            ]
          },
          {
            title: "Sec. 1.4 - AI System Inventory",
            description: "Maintain comprehensive inventory of all AI systems subject to TRAIGA",
            order_no: 4,
            summary: "Create and maintain a complete inventory of AI systems including their purpose, risk classification, deployment status, and compliance requirements",
            questions: [
              "Is there a complete inventory of AI systems?",
              "Are systems classified by risk level?",
              "Is the inventory kept current?",
              "Are new AI systems added to inventory before deployment?"
            ],
            evidence_examples: [
              "AI system inventory/register",
              "Risk classification records",
              "Inventory update procedures",
              "New system onboarding checklist"
            ]
          }
        ]
      },
      {
        title: "Chapter 2: Impact Assessments",
        description: "Requirements for conducting algorithmic impact assessments before deploying high-risk AI systems",
        order_no: 2,
        items: [
          {
            title: "Sec. 2.1 - Impact Assessment Requirements",
            description: "Conduct algorithmic impact assessments for all high-risk AI systems",
            order_no: 1,
            summary: "Before deploying high-risk AI, complete an impact assessment covering: purpose and intended use, data requirements, potential harms, bias analysis, and mitigation measures. Assessments must be documented and retained",
            questions: [
              "Are impact assessments completed before deployment?",
              "Do assessments cover all required elements?",
              "Is there a standardized assessment methodology?",
              "Are assessments documented and retained?"
            ],
            evidence_examples: [
              "Impact assessment templates",
              "Completed assessment documentation",
              "Assessment methodology guide",
              "Retention policy for assessments"
            ]
          },
          {
            title: "Sec. 2.2 - Bias and Discrimination Analysis",
            description: "Assess AI systems for potential discriminatory impacts on protected classes",
            order_no: 2,
            summary: "Evaluate whether AI systems may have disparate impact based on race, color, religion, sex, national origin, disability, age, or other protected characteristics. Document analysis methodology and findings",
            questions: [
              "Is bias testing conducted before deployment?",
              "Are all protected classes considered?",
              "Is there ongoing bias monitoring?",
              "Are mitigation measures documented when bias is found?"
            ],
            evidence_examples: [
              "Bias testing methodology",
              "Disparate impact analysis",
              "Protected class impact assessment",
              "Bias mitigation documentation"
            ]
          },
          {
            title: "Sec. 2.3 - Data Assessment",
            description: "Assess training data and input data for quality, representativeness, and potential biases",
            order_no: 3,
            summary: "Evaluate data sources, quality, representativeness, and potential embedded biases. Document data lineage, preprocessing steps, and quality assurance measures",
            questions: [
              "Is training data assessed for representativeness?",
              "Are data quality measures documented?",
              "Is data lineage tracked?",
              "Are data biases identified and addressed?"
            ],
            evidence_examples: [
              "Data quality assessment",
              "Data lineage documentation",
              "Representativeness analysis",
              "Data bias evaluation"
            ]
          },
          {
            title: "Sec. 2.4 - Periodic Reassessment",
            description: "Conduct periodic reassessments of deployed high-risk AI systems",
            order_no: 4,
            summary: "Impact assessments must be updated periodically and when significant changes occur. Establish reassessment schedule based on risk level and system changes",
            questions: [
              "Is there a reassessment schedule?",
              "Are reassessments triggered by significant changes?",
              "Are reassessment findings documented?",
              "Are corrective actions implemented when needed?"
            ],
            evidence_examples: [
              "Reassessment schedule",
              "Change trigger criteria",
              "Reassessment reports",
              "Corrective action records"
            ]
          },
          {
            title: "Sec. 2.5 - Third-Party Assessment",
            description: "Consider independent third-party assessments for highest-risk AI systems",
            order_no: 5,
            summary: "For AI systems with significant potential impact, consider engaging independent third parties to validate impact assessments and bias analyses",
            questions: [
              "Are third-party assessments conducted for highest-risk systems?",
              "Are assessors independent and qualified?",
              "Are third-party findings addressed?",
              "Is there a process for selecting assessors?"
            ],
            evidence_examples: [
              "Third-party assessment reports",
              "Assessor qualification verification",
              "Remediation of third-party findings",
              "Assessor selection criteria"
            ]
          }
        ]
      },
      {
        title: "Chapter 3: Transparency and Disclosure",
        description: "Requirements for transparency about AI use and disclosure to affected individuals",
        order_no: 3,
        items: [
          {
            title: "Sec. 3.1 - Consumer Disclosure Requirements",
            description: "Disclose to consumers when AI is used to make consequential decisions about them",
            order_no: 1,
            summary: "Consumers must be informed when high-risk AI makes or substantially contributes to decisions affecting them. Disclosure must be clear, conspicuous, and provided before or at the time of the decision",
            questions: [
              "Are consumers notified of AI use in decisions?",
              "Is disclosure clear and conspicuous?",
              "Is disclosure provided timely (before or at decision)?",
              "Are disclosure methods documented?"
            ],
            evidence_examples: [
              "Consumer disclosure notices",
              "Disclosure timing procedures",
              "Sample disclosure language",
              "Disclosure delivery records"
            ]
          },
          {
            title: "Sec. 3.2 - Statement of AI Use",
            description: "Provide statement describing how AI is used in consequential decisions",
            order_no: 2,
            summary: "Upon request, provide consumers with a statement describing: the AI system's role in the decision, key factors considered, data types used, and how to contest the decision",
            questions: [
              "Can statements be provided upon request?",
              "Do statements include all required information?",
              "Is there a process for handling requests?",
              "Are statements provided in accessible format?"
            ],
            evidence_examples: [
              "Statement of AI use template",
              "Request handling procedures",
              "Sample statements",
              "Accessibility accommodations"
            ]
          },
          {
            title: "Sec. 3.3 - Public Transparency",
            description: "Maintain public-facing transparency about high-risk AI use",
            order_no: 3,
            summary: "Make publicly available information about high-risk AI systems used, including general description, purpose, and contact information for questions or concerns",
            questions: [
              "Is AI use information publicly available?",
              "Is the information easy to find and understand?",
              "Is contact information provided?",
              "Is public information kept current?"
            ],
            evidence_examples: [
              "Public AI disclosure page",
              "Website AI information section",
              "Contact information for AI inquiries",
              "Public disclosure update records"
            ]
          },
          {
            title: "Sec. 3.4 - Explainability Requirements",
            description: "Ensure AI decisions can be explained to affected individuals",
            order_no: 4,
            summary: "Maintain ability to explain AI-driven decisions in understandable terms. Include principal factors, data elements, and logic contributing to decisions",
            questions: [
              "Can AI decisions be explained to consumers?",
              "Are explanations in plain language?",
              "Are key factors and data elements identified?",
              "Is there a process for providing explanations?"
            ],
            evidence_examples: [
              "Explanation generation capability",
              "Sample decision explanations",
              "Plain language guidelines",
              "Explanation request procedures"
            ]
          }
        ]
      },
      {
        title: "Chapter 4: Human Oversight",
        description: "Requirements for human oversight of high-risk AI systems and decisions",
        order_no: 4,
        items: [
          {
            title: "Sec. 4.1 - Human Review Process",
            description: "Establish processes for human review of AI-driven consequential decisions",
            order_no: 1,
            summary: "Implement meaningful human oversight of high-risk AI decisions. Humans must have ability to review, understand, and override AI recommendations when appropriate",
            questions: [
              "Is there human review of AI decisions?",
              "Can humans override AI recommendations?",
              "Do reviewers understand the AI system?",
              "Is human review documented?"
            ],
            evidence_examples: [
              "Human review procedures",
              "Override documentation",
              "Reviewer training records",
              "Review activity logs"
            ]
          },
          {
            title: "Sec. 4.2 - Appeal and Contest Rights",
            description: "Provide mechanisms for consumers to appeal or contest AI-driven decisions",
            order_no: 2,
            summary: "Consumers must be able to appeal consequential decisions made or influenced by AI. Appeals must include human review and consideration of additional information",
            questions: [
              "Is there an appeal process for AI decisions?",
              "Are appeals reviewed by humans?",
              "Can consumers provide additional information?",
              "Are appeal outcomes documented?"
            ],
            evidence_examples: [
              "Appeal procedures",
              "Appeal form/process",
              "Human review of appeals",
              "Appeal outcome records"
            ]
          },
          {
            title: "Sec. 4.3 - Opt-Out Rights",
            description: "Provide opt-out mechanisms where feasible for AI-driven decisions",
            order_no: 3,
            summary: "Where feasible, allow consumers to opt out of AI-driven decision-making and request human-only review. Document when opt-out is not feasible and why",
            questions: [
              "Can consumers opt out of AI decisions?",
              "Is the opt-out process accessible?",
              "Is human alternative available?",
              "Are opt-out limitations documented?"
            ],
            evidence_examples: [
              "Opt-out procedures",
              "Opt-out request handling",
              "Human alternative process",
              "Opt-out limitation justification"
            ]
          },
          {
            title: "Sec. 4.4 - Oversight Personnel Training",
            description: "Train personnel who oversee or review AI system outputs",
            order_no: 4,
            summary: "Personnel responsible for human oversight must receive adequate training on the AI system, its limitations, potential biases, and their oversight responsibilities",
            questions: [
              "Are oversight personnel trained?",
              "Does training cover AI limitations and biases?",
              "Is training documented and refreshed?",
              "Are competency requirements defined?"
            ],
            evidence_examples: [
              "Training program materials",
              "Training completion records",
              "Competency assessments",
              "Training refresh schedule"
            ]
          }
        ]
      },
      {
        title: "Chapter 5: Risk Management",
        description: "Requirements for managing risks associated with high-risk AI systems",
        order_no: 5,
        items: [
          {
            title: "Sec. 5.1 - Risk Management Program",
            description: "Establish and maintain an AI risk management program",
            order_no: 1,
            summary: "Implement a risk management program covering identification, assessment, mitigation, and monitoring of AI-related risks. Program should be proportionate to risk level",
            questions: [
              "Is there a documented AI risk management program?",
              "Does program cover full risk lifecycle?",
              "Is the program proportionate to risk?",
              "Is the program regularly reviewed?"
            ],
            evidence_examples: [
              "Risk management program documentation",
              "Risk identification procedures",
              "Risk assessment methodology",
              "Program review records"
            ]
          },
          {
            title: "Sec. 5.2 - Continuous Monitoring",
            description: "Implement continuous monitoring of high-risk AI system performance",
            order_no: 2,
            summary: "Monitor AI systems for performance degradation, drift, emerging biases, and unintended consequences. Establish monitoring metrics and alert thresholds",
            questions: [
              "Is AI performance continuously monitored?",
              "Are monitoring metrics defined?",
              "Are alert thresholds established?",
              "Is drift and bias monitored?"
            ],
            evidence_examples: [
              "Monitoring procedures",
              "Performance metrics dashboard",
              "Alert and escalation procedures",
              "Monitoring reports"
            ]
          },
          {
            title: "Sec. 5.3 - Incident Response",
            description: "Establish procedures for responding to AI-related incidents",
            order_no: 3,
            summary: "Define and implement procedures for identifying, reporting, investigating, and remediating AI system incidents including bias discoveries, errors, and harms",
            questions: [
              "Is there an AI incident response plan?",
              "Are incidents tracked and documented?",
              "Are root cause analyses conducted?",
              "Are corrective actions implemented?"
            ],
            evidence_examples: [
              "Incident response plan",
              "Incident tracking system",
              "Root cause analysis reports",
              "Corrective action records"
            ]
          },
          {
            title: "Sec. 5.4 - Model Governance",
            description: "Implement governance controls for AI model lifecycle",
            order_no: 4,
            summary: "Establish governance over the AI model lifecycle including development, validation, deployment, monitoring, and retirement. Control model changes and maintain version history",
            questions: [
              "Is there model governance framework?",
              "Are model changes controlled?",
              "Is version history maintained?",
              "Is there model validation process?"
            ],
            evidence_examples: [
              "Model governance framework",
              "Change control procedures",
              "Version control records",
              "Model validation documentation"
            ]
          }
        ]
      },
      {
        title: "Chapter 6: Data Governance",
        description: "Requirements for governing data used in high-risk AI systems",
        order_no: 6,
        items: [
          {
            title: "Sec. 6.1 - Training Data Requirements",
            description: "Ensure training data meets quality and representativeness requirements",
            order_no: 1,
            summary: "Training data must be relevant, representative, and appropriately assessed for bias. Document data sources, collection methods, and quality measures",
            questions: [
              "Is training data documented?",
              "Is data representativeness assessed?",
              "Are data sources vetted?",
              "Is data quality measured?"
            ],
            evidence_examples: [
              "Training data documentation",
              "Representativeness assessment",
              "Data source vetting records",
              "Data quality metrics"
            ]
          },
          {
            title: "Sec. 6.2 - Data Minimization",
            description: "Ensure data collection and use is limited to what is necessary",
            order_no: 2,
            summary: "Collect and use only data that is necessary for the AI system's purpose. Avoid collecting sensitive data unless required and justified",
            questions: [
              "Is data collection minimized?",
              "Is sensitive data use justified?",
              "Are data retention limits enforced?",
              "Is unnecessary data deleted?"
            ],
            evidence_examples: [
              "Data minimization assessment",
              "Sensitive data justification",
              "Retention policy compliance",
              "Data deletion records"
            ]
          },
          {
            title: "Sec. 6.3 - Protected Class Data Handling",
            description: "Appropriately handle data related to protected characteristics",
            order_no: 3,
            summary: "Implement appropriate safeguards for data related to protected characteristics. Such data may be needed for bias testing but requires additional protections",
            questions: [
              "Is protected class data identified?",
              "Are additional safeguards implemented?",
              "Is use limited to legitimate purposes?",
              "Is access restricted appropriately?"
            ],
            evidence_examples: [
              "Protected data inventory",
              "Additional safeguards documentation",
              "Use limitation policies",
              "Access control records"
            ]
          },
          {
            title: "Sec. 6.4 - Data Security",
            description: "Implement appropriate security measures for AI training and operational data",
            order_no: 4,
            summary: "Protect AI-related data with appropriate technical and organizational security measures. Security should be proportionate to data sensitivity",
            questions: [
              "Are AI data assets secured?",
              "Is security proportionate to sensitivity?",
              "Are access controls implemented?",
              "Is data encrypted appropriately?"
            ],
            evidence_examples: [
              "Security measures documentation",
              "Access control records",
              "Encryption implementation",
              "Security assessment results"
            ]
          }
        ]
      },
      {
        title: "Chapter 7: Documentation and Records",
        description: "Requirements for maintaining documentation and records related to AI systems",
        order_no: 7,
        items: [
          {
            title: "Sec. 7.1 - Technical Documentation",
            description: "Maintain technical documentation for high-risk AI systems",
            order_no: 1,
            summary: "Document AI system architecture, algorithms, training procedures, validation methods, and performance metrics. Documentation should enable understanding of system behavior",
            questions: [
              "Is technical documentation maintained?",
              "Does documentation cover system architecture?",
              "Are algorithms and methods documented?",
              "Is documentation kept current?"
            ],
            evidence_examples: [
              "System architecture documentation",
              "Algorithm documentation",
              "Training procedure documentation",
              "Documentation update records"
            ]
          },
          {
            title: "Sec. 7.2 - Decision Records",
            description: "Maintain records of consequential AI-driven decisions",
            order_no: 2,
            summary: "Keep records of consequential decisions made or influenced by AI, including inputs, outputs, and any human review or override. Enable reconstruction of decision basis",
            questions: [
              "Are decision records maintained?",
              "Do records include inputs and outputs?",
              "Is human review documented?",
              "Can decisions be reconstructed?"
            ],
            evidence_examples: [
              "Decision logging system",
              "Input/output records",
              "Human review documentation",
              "Decision audit trail"
            ]
          },
          {
            title: "Sec. 7.3 - Compliance Documentation",
            description: "Maintain documentation demonstrating TRAIGA compliance",
            order_no: 3,
            summary: "Compile and maintain documentation demonstrating compliance with all applicable TRAIGA requirements. Be prepared to provide documentation to regulators upon request",
            questions: [
              "Is compliance documentation organized?",
              "Can compliance be demonstrated?",
              "Is documentation accessible for review?",
              "Is documentation complete and current?"
            ],
            evidence_examples: [
              "Compliance documentation package",
              "Requirement mapping",
              "Evidence organization system",
              "Completeness assessment"
            ]
          },
          {
            title: "Sec. 7.4 - Record Retention",
            description: "Retain AI-related records for required periods",
            order_no: 4,
            summary: "Retain impact assessments, decision records, and compliance documentation for at least three years after the AI system is retired or the decision is made",
            questions: [
              "Is there a retention policy?",
              "Does retention meet minimum requirements?",
              "Are records securely stored?",
              "Is there a retention schedule?"
            ],
            evidence_examples: [
              "Retention policy",
              "Retention schedule",
              "Secure storage procedures",
              "Destruction records (when applicable)"
            ]
          }
        ]
      },
      {
        title: "Chapter 8: Vendor Management",
        description: "Requirements for managing third-party AI vendors and systems",
        order_no: 8,
        items: [
          {
            title: "Sec. 8.1 - Vendor Due Diligence",
            description: "Conduct due diligence on AI vendors before engagement",
            order_no: 1,
            summary: "Before using third-party AI systems, assess vendor compliance capabilities, system documentation, and ability to support your compliance obligations",
            questions: [
              "Is vendor due diligence conducted?",
              "Are vendor compliance capabilities assessed?",
              "Is vendor documentation adequate?",
              "Can vendor support your compliance needs?"
            ],
            evidence_examples: [
              "Vendor assessment questionnaire",
              "Due diligence reports",
              "Vendor documentation review",
              "Compliance support assessment"
            ]
          },
          {
            title: "Sec. 8.2 - Contractual Requirements",
            description: "Include appropriate provisions in AI vendor contracts",
            order_no: 2,
            summary: "Contracts with AI vendors should address: compliance obligations, documentation requirements, audit rights, incident notification, and liability allocation",
            questions: [
              "Do contracts address compliance obligations?",
              "Are documentation requirements included?",
              "Are audit rights secured?",
              "Is incident notification required?"
            ],
            evidence_examples: [
              "Contract compliance provisions",
              "Documentation requirements in contracts",
              "Audit right provisions",
              "Incident notification clauses"
            ]
          },
          {
            title: "Sec. 8.3 - Ongoing Vendor Monitoring",
            description: "Monitor vendor compliance and AI system performance",
            order_no: 3,
            summary: "Implement ongoing monitoring of AI vendors including periodic assessments, performance monitoring, and compliance verification",
            questions: [
              "Is vendor compliance monitored?",
              "Are periodic assessments conducted?",
              "Is vendor performance tracked?",
              "Are issues escalated and addressed?"
            ],
            evidence_examples: [
              "Vendor monitoring procedures",
              "Periodic assessment records",
              "Performance tracking reports",
              "Issue resolution records"
            ]
          },
          {
            title: "Sec. 8.4 - Vendor Incident Management",
            description: "Manage incidents involving third-party AI systems",
            order_no: 4,
            summary: "Establish procedures for receiving, assessing, and responding to incidents reported by or discovered in third-party AI systems",
            questions: [
              "Are vendor incident procedures established?",
              "Is there prompt notification from vendors?",
              "Are vendor incidents assessed?",
              "Is there coordinated response process?"
            ],
            evidence_examples: [
              "Vendor incident procedures",
              "Notification requirements",
              "Incident assessment records",
              "Response coordination documentation"
            ]
          }
        ]
      },
      {
        title: "Chapter 9: Enforcement Preparedness",
        description: "Preparation for regulatory enforcement and private actions under TRAIGA",
        order_no: 9,
        items: [
          {
            title: "Sec. 9.1 - Attorney General Cooperation",
            description: "Prepare for potential Attorney General inquiries and investigations",
            order_no: 1,
            summary: "Be prepared to respond to Attorney General requests for information, documentation, or access. Establish procedures for prompt and complete responses",
            questions: [
              "Is there a process for AG inquiries?",
              "Can documentation be produced promptly?",
              "Is there a designated contact?",
              "Are response procedures documented?"
            ],
            evidence_examples: [
              "AG inquiry response procedures",
              "Document production capability",
              "Designated contact information",
              "Response timeline procedures"
            ]
          },
          {
            title: "Sec. 9.2 - Cure Period Utilization",
            description: "Understand and prepare to use the cure period for violations",
            order_no: 2,
            summary: "TRAIGA provides a cure period for certain violations. Understand which violations are curable and maintain capability to implement cures promptly",
            questions: [
              "Is the cure period understood?",
              "Which violations are curable?",
              "Can cures be implemented promptly?",
              "Is cure documentation prepared?"
            ],
            evidence_examples: [
              "Cure period analysis",
              "Curable violation inventory",
              "Rapid response procedures",
              "Cure documentation templates"
            ]
          },
          {
            title: "Sec. 9.3 - Civil Penalty Avoidance",
            description: "Implement measures to avoid civil penalties",
            order_no: 3,
            summary: "Understand penalty structure and factors considered in penalty determination. Implement compliance measures and document good faith efforts to minimize potential penalties",
            questions: [
              "Is penalty structure understood?",
              "Are compliance measures documented?",
              "Is there evidence of good faith?",
              "Are high-risk areas prioritized?"
            ],
            evidence_examples: [
              "Penalty risk assessment",
              "Compliance measure documentation",
              "Good faith compliance evidence",
              "Prioritization records"
            ]
          },
          {
            title: "Sec. 9.4 - Private Right of Action Defense",
            description: "Prepare defenses against potential private lawsuits",
            order_no: 4,
            summary: "TRAIGA may enable private actions by affected consumers. Document compliance efforts and maintain records that can support defense against claims",
            questions: [
              "Is litigation risk understood?",
              "Are compliance efforts documented?",
              "Are consumer interactions recorded?",
              "Is there litigation response plan?"
            ],
            evidence_examples: [
              "Litigation risk assessment",
              "Compliance documentation",
              "Consumer interaction records",
              "Legal response procedures"
            ]
          }
        ]
      },
      {
        title: "Chapter 10: Governance and Accountability",
        description: "Organizational governance and accountability structures for AI compliance",
        order_no: 10,
        items: [
          {
            title: "Sec. 10.1 - AI Governance Structure",
            description: "Establish organizational governance structure for AI",
            order_no: 1,
            summary: "Implement governance structure with clear roles, responsibilities, and accountability for AI compliance. Include executive oversight and operational responsibilities",
            questions: [
              "Is there AI governance structure?",
              "Are roles and responsibilities defined?",
              "Is there executive oversight?",
              "Is accountability clear?"
            ],
            evidence_examples: [
              "AI governance charter",
              "Roles and responsibilities matrix",
              "Executive oversight documentation",
              "Accountability framework"
            ]
          },
          {
            title: "Sec. 10.2 - AI Ethics Committee",
            description: "Establish or designate an AI ethics review function",
            order_no: 2,
            summary: "Consider establishing an AI ethics committee or function to review high-risk AI use cases, assess ethical implications, and provide guidance",
            questions: [
              "Is there AI ethics review function?",
              "Are high-risk uses reviewed?",
              "Are ethical implications assessed?",
              "Is guidance provided and followed?"
            ],
            evidence_examples: [
              "AI ethics committee charter",
              "Review procedures",
              "Ethics assessment records",
              "Guidance documentation"
            ]
          },
          {
            title: "Sec. 10.3 - Compliance Program",
            description: "Implement comprehensive AI compliance program",
            order_no: 3,
            summary: "Establish a compliance program including policies, procedures, training, monitoring, and continuous improvement for TRAIGA compliance",
            questions: [
              "Is there AI compliance program?",
              "Are policies and procedures documented?",
              "Is training provided?",
              "Is continuous improvement implemented?"
            ],
            evidence_examples: [
              "Compliance program documentation",
              "Policies and procedures",
              "Training program and records",
              "Continuous improvement records"
            ]
          },
          {
            title: "Sec. 10.4 - Internal Audit",
            description: "Conduct internal audits of AI compliance",
            order_no: 4,
            summary: "Perform regular internal audits of AI compliance. Audit scope should cover all TRAIGA requirements with findings tracked to remediation",
            questions: [
              "Are internal audits conducted?",
              "Do audits cover all requirements?",
              "Are findings tracked?",
              "Is remediation completed?"
            ],
            evidence_examples: [
              "Audit program documentation",
              "Audit reports",
              "Finding tracking system",
              "Remediation records"
            ]
          },
          {
            title: "Sec. 10.5 - Board Reporting",
            description: "Report AI governance matters to board or senior leadership",
            order_no: 5,
            summary: "Provide regular reporting to board or senior leadership on AI risk, compliance status, significant incidents, and governance matters",
            questions: [
              "Is there board/leadership reporting?",
              "Does reporting cover key matters?",
              "Is reporting frequency appropriate?",
              "Are significant issues escalated?"
            ],
            evidence_examples: [
              "Board reporting procedures",
              "Sample board reports",
              "Reporting schedule",
              "Escalation procedures"
            ]
          }
        ]
      }
    ]
  }
};

// plugins/texas-ai-act/index.ts
var plugin = createFrameworkPlugin({
  key: "texas-ai-act",
  name: "Texas Responsible AI Governance Act (TRAIGA)",
  description: "Texas Responsible AI Governance Act compliance framework for organizations deploying high-risk AI systems in Texas.",
  version: "1.0.0",
  author: "VerifyWise",
  template: template_default.framework,
  autoImport: true
});
var { metadata, install, uninstall, validateConfig, router } = plugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  install,
  metadata,
  router,
  uninstall,
  validateConfig
});
